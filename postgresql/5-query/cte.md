# PostgreSQL CTE

A common table expression is a temporary result set which you can reference within another SQL statement including `SELECT`, `INSERT`, `UPDATE` or `DELETE`.

The CTEs are like temporary tables that exist only during the execution of the query.

Common Table Expressions or CTEs are typically used to simplify complex joins and subqueries in PostgreSQL.

The following shows the syntax of creating a CTE:

```sql
WITH cte_name (column_list) AS (
    CTE_query_definition 
)
statement;
```

```sql
WITH cte_film AS (
  SELECT 
    film_id, 
    title,
    (CASE 
      WHEN length < 30 THEN 'Short'
      WHEN length < 90 THEN 'Medium'
      ELSE 'Long'
    END) length    
  FROM
    film
)
SELECT
  film_id,
  title,
  length
FROM 
  cte_film
WHERE
  length = 'Long'
ORDER BY 
  title; 
```


## Joining a CTE with a table example

```sql
WITH cte_rental AS (
  SELECT staff_id,
    COUNT(rental_id) rental_count
  FROM rental
  GROUP BY staff_id
)
SELECT 
  s.staff_id,
  first_name,
  last_name,
  rental_count
FROM staff s
INNER JOIN cte_rental USING (staff_id); 
```


## Recursive query

A recursive query is a query that refers to a recursive CTE. 

The recursive queries are useful in many situations such as querying hierarchical data like organizational structure, bill of materials, etc.

The following illustrates the syntax of a recursive CTE:

```sql
WITH RECURSIVE cte_name AS(
    CTE_query_definition -- non-recursive term
    UNION [ALL]
    CTE_query definion  -- recursive term
) SELECT * FROM cte_name;
```

A recursive CTE has three elements:

- Non-recursive term: the non-recursive term is a CTE query definition that forms the base result set of the CTE structure.
- Recursive term: the recursive term is one or more CTE query definitions joined with the non-recursive term using the UNION or UNION ALL operator. The recursive term references the CTE name itself.
- Termination check: the recursion stops when no rows are returned from the previous iteration.


### Example

```sql
CREATE TABLE employees (
	employee_id serial PRIMARY KEY,
	full_name VARCHAR NOT NULL,
	manager_id INT
);
```

```sql
INSERT INTO employees (
	employee_id,
	full_name,
	manager_id
)
VALUES
	(1, 'Michael North', NULL),
	(2, 'Megan Berry', 1),
	(3, 'Sarah Berry', 1),
	(4, 'Zoe Black', 1),
	(5, 'Tim James', 1),
	(6, 'Bella Tucker', 2),
	(7, 'Ryan Metcalfe', 2),
	(8, 'Max Mills', 2),
	(9, 'Benjamin Glover', 2),
	(10, 'Carolyn Henderson', 3),
	(11, 'Nicola Kelly', 3),
	(12, 'Alexandra Climo', 3),
	(13, 'Dominic King', 3),
	(14, 'Leonard Gray', 4),
	(15, 'Eric Rampling', 4),
	(16, 'Piers Paige', 7),
	(17, 'Ryan Henderson', 7),
	(18, 'Frank Tucker', 8),
	(19, 'Nathan Ferguson', 8),
	(20, 'Kevin Rampling', 8);
```

The following query returns all subordinates of the manager with the id `2`:

```sql
WITH RECURSIVE subordinates AS (
	SELECT
		employee_id,
		manager_id,
		full_name
	FROM
		employees
	WHERE
		employee_id = 2
	UNION
		SELECT
			e.employee_id,
			e.manager_id,
			e.full_name
		FROM
			employees e
		INNER JOIN subordinates s ON s.employee_id = e.manager_id
) SELECT
	*
FROM
	subordinates;
```

**How it works:**

The non-recursive term returns the base result set R0 that is the employee with the id 2.

| employee_id | manager_id |  full_name |
-------------|------------|-------------
|2           |          1 | Megan Berry |

The first iteration of the recursive term returns the following result set:

| employee_id | manager_id |    full_name |
|-------------|------------|-----------------|
|           6 |          2 | Bella Tucker|
|           7 |          2 | Ryan Metcalfe |
|           8 |          2 | Max Mills |
|           9 |          2 | Benjamin Glover |

The second iteration of the recursive member uses the result set above step as the input value, and returns this result set:

| employee_id | manager_id |    full_name |
|-------------|------------|-----------------|
|          16 |          7 | Piers Paige |
|          17 |          7 | Ryan Henderson|
|          18 |          8 | Frank Tucker|
|          19 |          8 | Nathan Ferguson |
|          20 |          8 | Kevin Rampling |

The third iteration returns an empty result set

PostgreSQL returns the final result set that is the union of all result sets in the first and second iterations generated by the non-recursive and recursive terms.

| employee_id | manager_id |    full_name |
|------------- |------------ |----------------- |
|           2 |          1 | Megan Berry |
|           6 |          2 | Bella Tucker |
|           7 |          2 | Ryan Metcalfe |
|           8 |          2 | Max Mills |
|           9 |          2 | Benjamin Glover |
|          16 |          7 | Piers Paige |
|          17 |          7 | Ryan Henderson |
|          18 |          8 | Frank Tucker |
|          19 |          8 | Nathan Ferguson |
|          20 |          8 | Kevin Rampling |
