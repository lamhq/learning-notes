# Tables

## Basic table creation

```sql
CREATE TABLE logs (
  log_id serial PRIMARY KEY,
  user_name varchar(50),
  description text,
  log_ts timestamp with time zone NOT NULL DEFAULT current_timestamp
);

CREATE INDEX idx_logs_log_ts ON logs USING btree (log_ts);
```

- `serial` is the data type used to represent an incrementing autonumber. Adding a serial column automatically adds an accompanying sequence object to the database schema.

New in version 10 is the `IDENTITY` qualifier for a column. `IDENTITY` is a more standard-compliant way of generating an autonumber for a table column.

```sql
CREATE TABLE logs (
  log_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_name varchar(50),
  description text,
  log_ts timestamp with time zone NOT NULL DEFAULT current_timestamp
);
```

- an **identity** is always tied to a specific table, and create a sequence object, but preventing that sequence object from being edited directly.
- a **serial**, on the other hand, creates a sequence object that may or may not be reused by other tables and needs to be dropped manually when it’s no longer needed.
- if you wanted to reset the number of a serial, you’d need to modify the related `SEQUENCE` object (with its name)
- The **serial** approach is still useful if you need to reuse an autonumber generator across many tables.


## Inherited Tables

When you specify that a table inherits from another table, PostgreSQL creates the child table with its own columns plus all the columns of the parent table.

Any subsequent structural changes to the parent automatically propagate to its children.

When you query the parent table, PostgreSQL automatically includes all rows in the child tables.

Primary key constraints, foreign key constraints, uniqueness constraints, and indexes are never inherited.

```sql
CREATE TABLE logs_2011 (PRIMARY KEY (log_id)) INHERITS (logs);

CREATE INDEX idx_logs_2011_log_ts ON logs_2011 USING btree(log_ts);

ALTER TABLE logs_2011 ADD CONSTRAINT chk_y2011 CHECK (
  log_ts >= '2011-1-1'::timestamptz AND log_ts < '2012-1-1'::timestamptz);
```


## Partitioned Tables

Partitioned tables are much like inherited tables in that they allow partitioning of data across many tables and the planner can conditionally skip tables that don’t satisfy a query condition.

A partitioned table group is created using the declarative partition syntax `CREATE TABLE .. PARTITION BY RANGE ...`

When partitions are used, data can be inserted into the core table and is rerouted automatically to the matching partition. With inherited tables, where you either need to insert data into the child table, or have a trigger that reroutes data to the child tables.

All tables in a partition must have the same exact columns. Though inherited tables, where child tables are allowed to have additional columns that are not in the parent tables.

Each partitioned table belongs to a single partitioned group. Internally that means it can have only one parent table. Inherited tables, on other hand, can inherit columns from multiple tables.


## Unlogged Tables

The `UNLOGGED` modifier allows you to create unlogged tables, These tables will not be part of any write- ahead logs. The big advantage of an unlogged table is that writing data to it is much faster than to a logged table


## TYPE OF

PostgreSQL automatically creates a corresponding composite data type in the background whenever you create a new table

You can use a composite data type as a template for creating tables

```sql
CREATE TYPE basic_user AS (user_name varchar(50), pwd varchar(10));

CREATE TABLE super_users OF basic_user (CONSTRAINT pk_su PRIMARY KEY (user_name));
```